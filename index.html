<!DOCTYPE html>
<html>
    <head>
        <title>Part Comparison</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="cpuData.js"></script>
        <link rel="stylesheet" href="style.css">

    </head>
    <body>
        <header class="center-align">
            <h1>PC Part Analysis</h1>
        </header>
        <div id="filterDiv">
            <div>
                <label for="priceWeightSlider">Price</label>
                <input type="range" min="0" max="1" value="1" step="0.1" class="slider" id="priceWeightSlider">
            </div>
            <div>
                <label for="core_countWeightSlider">Cores</label>
                <input type="range" min="0" max="1" value="1" step="0.1" class="slider" id="core_countWeightSlider">
            </div>

            <div>
                <label for="core_clockWeightSlider">Clock Speed</label>
                <input type="range" min="0" max="1" value="1" step="0.1" class="slider" id="core_clockWeightSlider">
            </div>
            
            <div>
                <label for="tdpWeightSlider">TDP</label>
                <input type="range" min="0" max="1" value="0" step="0.1" class="slider" id="tdpWeightSlider">
            </div>
        </div>
        <div class="center-align create-table">
            <button onclick="createTable();">Regenerate Table</button>
        </div>
        <div id="table">
            <table>
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Ranking</th>
                        <th>Price</th>
                        <th>Cores</th>
                        <th>Clock Speed</th>
                        <th>TDP</th>
                    </tr>
                </thead>
                <tbody id="mainTable">

                </tbody>
            </table>
        </div>
    </body>
    <script>
        let attributes = ["price","core_count","core_clock","tdp"];
        let attributeFormat = {
            "price" : "dataHere",
            "core_count" : "dataHere",
            "core_clock" : "dataHere GHz",
            "tdp": "dataHereW"
        };
        let reverseSort = ["price"];
        let partData = cpuData;

        const formatter = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',

            // These options can be used to round to whole numbers.
            trailingZeroDisplay: 'stripIfInteger'   // This is probably what most people
                                                    // want. It will only stop printing
                                                    // the fraction when the input
                                                    // amount is a round number (int)
                                                    // already. If that's not what you
                                                    // need, have a look at the options
                                                    // below.
        });

        function getWeights() {
            let weightDict = {};
            for (let attr of attributes) {
                if (document.getElementById(attr+"WeightSlider")) {
                    weightDict[attr] = document.getElementById(attr+"WeightSlider").value;
                } else {
                    weightDict[attr] = 1;
                }
            }
            return weightDict;
        }

        function getPercentile(array,element, reverse) {
            let count = 0;
            array.forEach(v => {
                if (v < element) {
                count++;
                } else if (v == element) {
                count += 0.5;
                }
            });
            if (reverse !== undefined && reverse) {
                return 1-(count / array.length);
            }
            return count / array.length;
        }

        function getPartByName(partName) {
            for (let p of partData) {
                if (p["name"] == partName) {
                    return p;
                }
            }
            return null;
        }

        function getValueArray(key) {
            let d = [];
            for (let el of partData) {
                d.push(el[key]);
            }
            return d;
        }

        function formatElementByRank(element,rank) {
            let finalColor = 0;
            finalColor = Math.pow(rank,3) * 200;
            element.style = `background-color: hsl(${finalColor}, 100%, 50%);`;
        }

        function easyGetPercentile(element, key, reverse, arr) {
            if (typeof(arr) == "undefined") {
                arr = getValueArray(key).sort(compareFn = numberCompFn);
            }
            return getPercentile(arr, element[key], reverse);
        }

        let numberCompFn = (a, b) => (a > b);

        //Now to calculate the weighted score of each part

        let tableBody = document.getElementById("mainTable");

        function createTable() {
            let rawValueDict = {};
            let rawRankDict = {};
            let rawValueArr = [];

            let sortedArrayDict = {}; // This will precompute the sorted arrays for each attribute. Since this shouldn't change during runtime, it's okay to run these calculations ahead of time. This saves a ridiculous amount of loading time.
            for (let attr of attributes) {
                sortedArrayDict[attr] = getValueArray(attr).sort(compareFn = numberCompFn);
            }

            for (let part of partData) {
                let rawRankData = {};
                let rawValue = 0;
                for (let attr of attributes) {
                    let attrValue = easyGetPercentile(part,attr,reverseSort.includes(attr), sortedArrayDict[attr]);
                    rawRankData[attr] = attrValue;
                    rawValue += attrValue * getWeights()[attr];
                }

                rawValueArr.push(rawValue);
                rawValueDict[part["name"]] = rawValue;
                rawRankDict[part["name"]] = rawRankData;
            }

            let finalValueDict = []; //Finally, to get the final distribution across elements
            
            for (let part of partData) {
                let v = rawValueDict[part['name']];
                let finalValue = getPercentile(rawValueArr.sort(compareFn=numberCompFn),v);
                finalValueDict.push({"name": part['name'], "value":finalValue});
            }

            //first clear the table

            finalValueDict = finalValueDict.sort(compareFn = (a,b) => (a["value"] > b["value"])).reverse();
            while(tableBody.firstChild) {
                tableBody.removeChild(tableBody.firstChild);
            }

            //then add each element in sequence
            for (let part of finalValueDict) {
                let newRow = document.createElement("tr");
                let newName = document.createElement("th");
                
                let newRanking = document.createElement("td");

                let thisPartData = getPartByName(part["name"]);
                let rank = part["value"];

                newName.textContent = thisPartData["name"];
                newRanking.textContent = (rank*100).toPrecision(4).toString()+"%";

                formatElementByRank(newRanking, rank); 

                tableBody.appendChild(newRow);
                newRow.appendChild(newName);
                newRow.appendChild(newRanking);
                for (let attr of attributes) {
                    let newTablePiece = document.createElement("td");
                    let text = (attr == "price") ? formatter.format(thisPartData[attr]) : new Intl.NumberFormat().format(thisPartData[attr]);
                    newTablePiece.textContent = attributeFormat[attr].replace("dataHere",text);
                    newRow.append(newTablePiece);
                }
            }

        }
        //console.log(finalValueDict.sort(compareFn = (a,b) => (a["value"] > b["value"])).reverse());
        createTable();

    </script>
</html>